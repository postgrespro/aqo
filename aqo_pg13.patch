diff --git a/contrib/Makefile b/contrib/Makefile
index 7a4866e338..47a18b9698 100644
--- a/contrib/Makefile
+++ b/contrib/Makefile
@@ -7,6 +7,7 @@ include $(top_builddir)/src/Makefile.global
 SUBDIRS = \
 		adminpack	\
 		amcheck		\
+		aqo		\
 		auth_delay	\
 		auto_explain	\
 		bloom		\
diff --git a/src/backend/commands/explain.c b/src/backend/commands/explain.c
index 5d7eb3574c..87402b6859 100644
--- a/src/backend/commands/explain.c
+++ b/src/backend/commands/explain.c
@@ -24,6 +24,7 @@
 #include "nodes/extensible.h"
 #include "nodes/makefuncs.h"
 #include "nodes/nodeFuncs.h"
+#include "optimizer/cost.h"
 #include "parser/parsetree.h"
 #include "rewrite/rewriteHandler.h"
 #include "storage/bufmgr.h"
@@ -46,6 +47,9 @@ ExplainOneQuery_hook_type ExplainOneQuery_hook = NULL;
 /* Hook for plugins to get control in explain_get_index_name() */
 explain_get_index_name_hook_type explain_get_index_name_hook = NULL;
 
+/* Hook for plugins to get control in ExplainOnePlan() */
+ExplainOnePlan_hook_type ExplainOnePlan_hook = NULL;
+
 
 /* OR-able flags for ExplainXMLTag() */
 #define X_OPENING 0
@@ -654,6 +658,10 @@ ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es,
 		ExplainPropertyFloat("Execution Time", "ms", 1000.0 * totaltime, 3,
 							 es);
 
+	if (ExplainOnePlan_hook)
+		ExplainOnePlan_hook(plannedstmt, into, es,
+							queryString, params, planduration, queryEnv);
+
 	ExplainCloseGroup("Query", NULL, true, es);
 }
 
@@ -1595,6 +1603,38 @@ ExplainNode(PlanState *planstate, List *ancestors,
 				appendStringInfo(es->str,
 								 " (actual rows=%.0f loops=%.0f)",
 								 rows, nloops);
+
+#ifdef AQO_EXPLAIN
+			if (es->verbose && plan && planstate->instrument)
+			{
+				int wrkrs = 1;
+				double error = -1.;
+
+				if (planstate->worker_instrument && IsParallelTuplesProcessing(plan))
+				{
+					int i;
+					for (i = 0; i < planstate->worker_instrument->num_workers; i++)
+					{
+						Instrumentation *instrument = &planstate->worker_instrument->instrument[i];
+						if (instrument->nloops <= 0)
+							continue;
+						wrkrs++;
+					}
+				}
+
+				if (plan->predicted_cardinality > 0.)
+				{
+					error = 100. * (plan->predicted_cardinality - (rows*wrkrs))
+												/ plan->predicted_cardinality;
+					appendStringInfo(es->str,
+					" (AQO: cardinality=%.0lf, error=%.0lf%%, fsspace_hash=%d)",
+							plan->predicted_cardinality, error, plan->fss_hash);
+				}
+				else
+					appendStringInfo(es->str, " (AQO not used, fsspace_hash=%d)",
+																plan->fss_hash);
+			}
+#endif
 		}
 		else
 		{
diff --git a/src/backend/nodes/copyfuncs.c b/src/backend/nodes/copyfuncs.c
index ba3ccc712c..74a090e6f9 100644
--- a/src/backend/nodes/copyfuncs.c
+++ b/src/backend/nodes/copyfuncs.c
@@ -126,6 +126,12 @@ CopyPlanFields(const Plan *from, Plan *newnode)
 	COPY_NODE_FIELD(lefttree);
 	COPY_NODE_FIELD(righttree);
 	COPY_NODE_FIELD(initPlan);
+	COPY_SCALAR_FIELD(had_path);
+	COPY_NODE_FIELD(path_clauses);
+	COPY_NODE_FIELD(path_relids);
+	COPY_SCALAR_FIELD(path_jointype);
+	COPY_SCALAR_FIELD(path_parallel_workers);
+	COPY_SCALAR_FIELD(was_parametrized);
 	COPY_BITMAPSET_FIELD(extParam);
 	COPY_BITMAPSET_FIELD(allParam);
 }
diff --git a/src/backend/optimizer/path/costsize.c b/src/backend/optimizer/path/costsize.c
index 380336518f..ecf0c45629 100644
--- a/src/backend/optimizer/path/costsize.c
+++ b/src/backend/optimizer/path/costsize.c
@@ -97,6 +97,11 @@
 #include "utils/spccache.h"
 #include "utils/tuplesort.h"
 
+set_baserel_rows_estimate_hook_type set_baserel_rows_estimate_hook = NULL;
+set_foreign_rows_estimate_hook_type set_foreign_rows_estimate_hook = NULL;
+get_parameterized_baserel_size_hook_type get_parameterized_baserel_size_hook = NULL;
+get_parameterized_joinrel_size_hook_type get_parameterized_joinrel_size_hook = NULL;
+set_joinrel_size_estimates_hook_type set_joinrel_size_estimates_hook = NULL;
 
 #define LOG2(x)  (log(x) / 0.693147180559945)
 
@@ -185,7 +190,6 @@ static Cost append_nonpartial_cost(List *subpaths, int numpaths,
 static void set_rel_width(PlannerInfo *root, RelOptInfo *rel);
 static double relation_byte_size(double tuples, int width);
 static double page_size(double tuples, int width);
-static double get_parallel_divisor(Path *path);
 
 
 /*
@@ -266,7 +270,7 @@ cost_seqscan(Path *path, PlannerInfo *root,
 	/* Adjust costing for parallelism, if used. */
 	if (path->parallel_workers > 0)
 	{
-		double		parallel_divisor = get_parallel_divisor(path);
+		double		parallel_divisor = get_parallel_divisor(path->parallel_workers);
 
 		/* The CPU cost is divided among all the workers. */
 		cpu_run_cost /= parallel_divisor;
@@ -745,7 +749,7 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count,
 	/* Adjust costing for parallelism, if used. */
 	if (path->path.parallel_workers > 0)
 	{
-		double		parallel_divisor = get_parallel_divisor(&path->path);
+		double		parallel_divisor = get_parallel_divisor(path->path.parallel_workers);
 
 		path->path.rows = clamp_row_est(path->path.rows / parallel_divisor);
 
@@ -1026,7 +1030,7 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	/* Adjust costing for parallelism, if used. */
 	if (path->parallel_workers > 0)
 	{
-		double		parallel_divisor = get_parallel_divisor(path);
+		double		parallel_divisor = get_parallel_divisor(path->parallel_workers);
 
 		/* The CPU cost is divided among all the workers. */
 		cpu_run_cost /= parallel_divisor;
@@ -2129,7 +2133,7 @@ cost_append(AppendPath *apath)
 	else						/* parallel-aware */
 	{
 		int			i = 0;
-		double		parallel_divisor = get_parallel_divisor(&apath->path);
+		double		parallel_divisor = get_parallel_divisor(apath->path.parallel_workers);
 
 		/* Parallel-aware Append never produces ordered output. */
 		Assert(apath->path.pathkeys == NIL);
@@ -2163,7 +2167,7 @@ cost_append(AppendPath *apath)
 			{
 				double		subpath_parallel_divisor;
 
-				subpath_parallel_divisor = get_parallel_divisor(subpath);
+				subpath_parallel_divisor = get_parallel_divisor(subpath->parallel_workers);
 				apath->path.rows += subpath->rows * (subpath_parallel_divisor /
 													 parallel_divisor);
 				apath->path.total_cost += subpath->total_cost;
@@ -2762,7 +2766,7 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
 	/* For partial paths, scale row estimate. */
 	if (path->path.parallel_workers > 0)
 	{
-		double		parallel_divisor = get_parallel_divisor(&path->path);
+		double		parallel_divisor = get_parallel_divisor(path->path.parallel_workers);
 
 		path->path.rows =
 			clamp_row_est(path->path.rows / parallel_divisor);
@@ -3208,7 +3212,7 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	/* For partial paths, scale row estimate. */
 	if (path->jpath.path.parallel_workers > 0)
 	{
-		double		parallel_divisor = get_parallel_divisor(&path->jpath.path);
+		double		parallel_divisor = get_parallel_divisor(path->jpath.path.parallel_workers);
 
 		path->jpath.path.rows =
 			clamp_row_est(path->jpath.path.rows / parallel_divisor);
@@ -3542,7 +3546,7 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * number, so we need to undo the division.
 	 */
 	if (parallel_hash)
-		inner_path_rows_total *= get_parallel_divisor(inner_path);
+		inner_path_rows_total *= get_parallel_divisor(inner_path->parallel_workers);
 
 	/*
 	 * Get hash table size that executor would use for inner relation.
@@ -3639,7 +3643,7 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	/* For partial paths, scale row estimate. */
 	if (path->jpath.path.parallel_workers > 0)
 	{
-		double		parallel_divisor = get_parallel_divisor(&path->jpath.path);
+		double		parallel_divisor = get_parallel_divisor(path->jpath.path.parallel_workers);
 
 		path->jpath.path.rows =
 			clamp_row_est(path->jpath.path.rows / parallel_divisor);
@@ -4634,6 +4638,58 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
 }
 
 
+void
+set_foreign_rows_estimate(PlannerInfo *root, RelOptInfo *rel)
+{
+	if (set_foreign_rows_estimate_hook)
+		(*set_foreign_rows_estimate_hook) (root, rel);
+	else
+		rel->rows = 1000;			/* entirely bogus default estimate */
+}
+
+/*
+ * set_baserel_rows_estimate
+ *		Set the rows estimate for the given base relation.
+ *
+ * Rows is the estimated number of output tuples after applying
+ * restriction clauses.
+ *
+ * To support loadable plugins that monitor or modify cardinality estimation,
+ * we provide a hook variable that lets a plugin get control before and
+ * after the cardinality estimation.
+ * The hook must set rel->rows.
+ */
+void
+set_baserel_rows_estimate(PlannerInfo *root, RelOptInfo *rel)
+{
+	if (set_baserel_rows_estimate_hook)
+		(*set_baserel_rows_estimate_hook) (root, rel);
+	else
+		set_baserel_rows_estimate_standard(root, rel);
+}
+
+/*
+ * set_baserel_rows_estimate
+ *		Set the rows estimate for the given base relation.
+ *
+ * Rows is the estimated number of output tuples after applying
+ * restriction clauses.
+ */
+void
+set_baserel_rows_estimate_standard(PlannerInfo *root, RelOptInfo *rel)
+{
+	double		nrows;
+
+	nrows = rel->tuples *
+		clauselist_selectivity(root,
+							   rel->baserestrictinfo,
+							   0,
+							   JOIN_INNER,
+							   NULL);
+
+	rel->rows = clamp_row_est(nrows);
+}
+
 /*
  * set_baserel_size_estimates
  *		Set the size estimates for the given base relation.
@@ -4650,19 +4706,10 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
 void
 set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 {
-	double		nrows;
-
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
-	nrows = rel->tuples *
-		clauselist_selectivity(root,
-							   rel->baserestrictinfo,
-							   0,
-							   JOIN_INNER,
-							   NULL);
-
-	rel->rows = clamp_row_est(nrows);
+	set_baserel_rows_estimate(root, rel);
 
 	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
 
@@ -4673,13 +4720,33 @@ set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  * get_parameterized_baserel_size
  *		Make a size estimate for a parameterized scan of a base relation.
  *
+ * To support loadable plugins that monitor or modify cardinality estimation,
+ * we provide a hook variable that lets a plugin get control before and
+ * after the cardinality estimation.
+ */
+double
+get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
+							   List *param_clauses)
+{
+	if (get_parameterized_baserel_size_hook)
+		return (*get_parameterized_baserel_size_hook) (root, rel,
+													   param_clauses);
+	else
+		return get_parameterized_baserel_size_standard(root, rel,
+													   param_clauses);
+}
+
+/*
+ * get_parameterized_baserel_size_standard
+ *		Make a size estimate for a parameterized scan of a base relation.
+ *
  * 'param_clauses' lists the additional join clauses to be used.
  *
  * set_baserel_size_estimates must have been applied already.
  */
 double
-get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
-							   List *param_clauses)
+get_parameterized_baserel_size_standard(PlannerInfo *root, RelOptInfo *rel,
+										List *param_clauses)
 {
 	List	   *allclauses;
 	double		nrows;
@@ -4708,6 +4775,36 @@ get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
  * set_joinrel_size_estimates
  *		Set the size estimates for the given join relation.
  *
+ * To support loadable plugins that monitor or modify cardinality estimation,
+ * we provide a hook variable that lets a plugin get control before and
+ * after the cardinality estimation.
+ * The hook must set rel->rows value.
+ */
+void
+set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
+						   RelOptInfo *outer_rel,
+						   RelOptInfo *inner_rel,
+						   SpecialJoinInfo *sjinfo,
+						   List *restrictlist)
+{
+	if (set_joinrel_size_estimates_hook)
+		(*set_joinrel_size_estimates_hook) (root, rel,
+											outer_rel,
+											inner_rel,
+											sjinfo,
+											restrictlist);
+	else
+		set_joinrel_size_estimates_standard(root, rel,
+											outer_rel,
+											inner_rel,
+											sjinfo,
+											restrictlist);
+}
+
+/*
+ * set_joinrel_size_estimates_standard
+ *		Set the size estimates for the given join relation.
+ *
  * The rel's targetlist must have been constructed already, and a
  * restriction clause list that matches the given component rels must
  * be provided.
@@ -4727,11 +4824,11 @@ get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
  * build_joinrel_tlist, and baserestrictcost is not used for join rels.
  */
 void
-set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
-						   RelOptInfo *outer_rel,
-						   RelOptInfo *inner_rel,
-						   SpecialJoinInfo *sjinfo,
-						   List *restrictlist)
+set_joinrel_size_estimates_standard(PlannerInfo *root, RelOptInfo *rel,
+									RelOptInfo *outer_rel,
+									RelOptInfo *inner_rel,
+									SpecialJoinInfo *sjinfo,
+									List *restrictlist)
 {
 	rel->rows = calc_joinrel_size_estimate(root,
 										   rel,
@@ -4747,6 +4844,35 @@ set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
  * get_parameterized_joinrel_size
  *		Make a size estimate for a parameterized scan of a join relation.
  *
+ * To support loadable plugins that monitor or modify cardinality estimation,
+ * we provide a hook variable that lets a plugin get control before and
+ * after the cardinality estimation.
+ */
+double
+get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
+							   Path *outer_path,
+							   Path *inner_path,
+							   SpecialJoinInfo *sjinfo,
+							   List *restrict_clauses)
+{
+	if (get_parameterized_joinrel_size_hook)
+		return (*get_parameterized_joinrel_size_hook) (root, rel,
+													   outer_path,
+													   inner_path,
+													   sjinfo,
+													   restrict_clauses);
+	else
+		return get_parameterized_joinrel_size_standard(root, rel,
+													   outer_path,
+													   inner_path,
+													   sjinfo,
+													   restrict_clauses);
+}
+
+/*
+ * get_parameterized_joinrel_size_standard
+ *		Make a size estimate for a parameterized scan of a join relation.
+ *
  * 'rel' is the joinrel under consideration.
  * 'outer_path', 'inner_path' are (probably also parameterized) Paths that
  *		produce the relations being joined.
@@ -4759,11 +4885,11 @@ set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
  * set_joinrel_size_estimates must have been applied already.
  */
 double
-get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
-							   Path *outer_path,
-							   Path *inner_path,
-							   SpecialJoinInfo *sjinfo,
-							   List *restrict_clauses)
+get_parameterized_joinrel_size_standard(PlannerInfo *root, RelOptInfo *rel,
+										Path *outer_path,
+										Path *inner_path,
+										SpecialJoinInfo *sjinfo,
+										List *restrict_clauses)
 {
 	double		nrows;
 
@@ -5479,7 +5605,7 @@ set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
-	rel->rows = 1000;			/* entirely bogus default estimate */
+	set_foreign_rows_estimate(root, rel);
 
 	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
 
@@ -5761,14 +5887,25 @@ page_size(double tuples, int width)
 	return ceil(relation_byte_size(tuples, width) / BLCKSZ);
 }
 
+bool
+IsParallelTuplesProcessing(const Plan *plan)
+{
+	if (plan->path_parallel_workers > 0 && (
+		plan->parallel_aware || nodeTag(plan) == T_HashJoin ||
+								nodeTag(plan) == T_MergeJoin ||
+								nodeTag(plan) == T_NestLoop))
+		return true;
+	return false;
+}
+
 /*
  * Estimate the fraction of the work that each worker will do given the
  * number of workers budgeted for the path.
  */
-static double
-get_parallel_divisor(Path *path)
+double
+get_parallel_divisor(int parallel_workers)
 {
-	double		parallel_divisor = path->parallel_workers;
+	double		parallel_divisor = parallel_workers;
 
 	/*
 	 * Early experience with parallel query suggests that when there is only
@@ -5785,7 +5922,7 @@ get_parallel_divisor(Path *path)
 	{
 		double		leader_contribution;
 
-		leader_contribution = 1.0 - (0.3 * path->parallel_workers);
+		leader_contribution = 1.0 - (0.3 * parallel_workers);
 		if (leader_contribution > 0)
 			parallel_divisor += leader_contribution;
 	}
diff --git a/src/backend/optimizer/plan/createplan.c b/src/backend/optimizer/plan/createplan.c
index 25d4750ca6..d0ea7bd2ff 100644
--- a/src/backend/optimizer/plan/createplan.c
+++ b/src/backend/optimizer/plan/createplan.c
@@ -70,6 +70,8 @@
 #define CP_LABEL_TLIST		0x0004	/* tlist must contain sortgrouprefs */
 #define CP_IGNORE_TLIST		0x0008	/* caller will replace tlist */
 
+/* Hook for plugins to get control in creating plan from path */
+copy_generic_path_info_hook_type copy_generic_path_info_hook = NULL;
 
 static Plan *create_plan_recurse(PlannerInfo *root, Path *best_path,
 								 int flags);
@@ -166,7 +168,7 @@ static Node *fix_indexqual_clause(PlannerInfo *root,
 static Node *fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol);
 static List *get_switched_clauses(List *clauses, Relids outerrelids);
 static List *order_qual_clauses(PlannerInfo *root, List *clauses);
-static void copy_generic_path_info(Plan *dest, Path *src);
+static void copy_generic_path_info(PlannerInfo *root, Plan *dest, Path *src);
 static void copy_plan_costsize(Plan *dest, Plan *src);
 static void label_sort_with_costsize(PlannerInfo *root, Sort *plan,
 									 double limit_tuples);
@@ -1110,7 +1112,7 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path, int flags)
 																	  false)),
 									NULL);
 
-		copy_generic_path_info(plan, (Path *) best_path);
+		copy_generic_path_info(root, plan, (Path *) best_path);
 
 		return plan;
 	}
@@ -1257,7 +1259,7 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path, int flags)
 	plan->first_partial_plan = best_path->first_partial_path;
 	plan->part_prune_info = partpruneinfo;
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, &best_path->path);
 
 	/*
 	 * If prepare_sort_from_pathkeys added sort columns, but we were told to
@@ -1303,7 +1305,7 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path,
 	 * prepare_sort_from_pathkeys on it before we do so on the individual
 	 * child plans, to make cross-checking the sort info easier.
 	 */
-	copy_generic_path_info(plan, (Path *) best_path);
+	copy_generic_path_info(root, plan, &best_path->path);
 	plan->targetlist = tlist;
 	plan->qual = NIL;
 	plan->lefttree = NULL;
@@ -1456,7 +1458,7 @@ create_group_result_plan(PlannerInfo *root, GroupResultPath *best_path)
 
 	plan = make_result(tlist, (Node *) quals, NULL);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, &best_path->path);
 
 	return plan;
 }
@@ -1481,7 +1483,7 @@ create_project_set_plan(PlannerInfo *root, ProjectSetPath *best_path)
 
 	plan = make_project_set(tlist, subplan);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, &best_path->path);
 
 	return plan;
 }
@@ -1509,7 +1511,7 @@ create_material_plan(PlannerInfo *root, MaterialPath *best_path, int flags)
 
 	plan = make_material(subplan);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, &best_path->path);
 
 	return plan;
 }
@@ -1709,7 +1711,7 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path, int flags)
 	}
 
 	/* Copy cost data from Path to Plan */
-	copy_generic_path_info(plan, &best_path->path);
+	copy_generic_path_info(root, plan, &best_path->path);
 
 	return plan;
 }
@@ -1744,7 +1746,7 @@ create_gather_plan(PlannerInfo *root, GatherPath *best_path)
 							  best_path->single_copy,
 							  subplan);
 
-	copy_generic_path_info(&gather_plan->plan, &best_path->path);
+	copy_generic_path_info(root, &gather_plan->plan, &best_path->path);
 
 	/* use parallel mode for parallel plans. */
 	root->glob->parallelModeNeeded = true;
@@ -1773,7 +1775,7 @@ create_gather_merge_plan(PlannerInfo *root, GatherMergePath *best_path)
 	gm_plan = makeNode(GatherMerge);
 	gm_plan->plan.targetlist = tlist;
 	gm_plan->num_workers = best_path->num_workers;
-	copy_generic_path_info(&gm_plan->plan, &best_path->path);
+	copy_generic_path_info(root, &gm_plan->plan, &best_path->path);
 
 	/* Assign the rescan Param. */
 	gm_plan->rescan_param = assign_special_exec_param(root);
@@ -1903,7 +1905,7 @@ create_projection_plan(PlannerInfo *root, ProjectionPath *best_path, int flags)
 		/* We need a Result node */
 		plan = (Plan *) make_result(tlist, NULL, subplan);
 
-		copy_generic_path_info(plan, (Path *) best_path);
+		copy_generic_path_info(root, plan, (Path *) best_path);
 	}
 
 	return plan;
@@ -2004,7 +2006,7 @@ create_sort_plan(PlannerInfo *root, SortPath *best_path, int flags)
 								   IS_OTHER_REL(best_path->subpath->parent) ?
 								   best_path->path.parent->relids : NULL);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2030,7 +2032,7 @@ create_incrementalsort_plan(PlannerInfo *root, IncrementalSortPath *best_path,
 											  best_path->spath.path.parent->relids : NULL,
 											  best_path->nPresortedCols);
 
-	copy_generic_path_info(&plan->sort.plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->sort.plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2069,7 +2071,7 @@ create_group_plan(PlannerInfo *root, GroupPath *best_path)
 												  subplan->targetlist),
 					  subplan);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2097,7 +2099,7 @@ create_upper_unique_plan(PlannerInfo *root, UpperUniquePath *best_path, int flag
 									 best_path->path.pathkeys,
 									 best_path->numkeys);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2141,7 +2143,7 @@ create_agg_plan(PlannerInfo *root, AggPath *best_path)
 					best_path->transitionSpace,
 					subplan);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2343,7 +2345,7 @@ create_groupingsets_plan(PlannerInfo *root, GroupingSetsPath *best_path)
 						subplan);
 
 		/* Copy cost data from Path to Plan */
-		copy_generic_path_info(&plan->plan, &best_path->path);
+		copy_generic_path_info(root, &plan->plan, &best_path->path);
 	}
 
 	return (Plan *) plan;
@@ -2401,7 +2403,7 @@ create_minmaxagg_plan(PlannerInfo *root, MinMaxAggPath *best_path)
 
 	plan = make_result(tlist, (Node *) best_path->quals, NULL);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	/*
 	 * During setrefs.c, we'll need to replace references to the Agg nodes
@@ -2520,7 +2522,7 @@ create_windowagg_plan(PlannerInfo *root, WindowAggPath *best_path)
 						  wc->inRangeNullsFirst,
 						  subplan);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2556,7 +2558,7 @@ create_setop_plan(PlannerInfo *root, SetOpPath *best_path, int flags)
 					  best_path->firstFlag,
 					  numGroups);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2592,7 +2594,7 @@ create_recursiveunion_plan(PlannerInfo *root, RecursiveUnionPath *best_path)
 								best_path->distinctList,
 								numGroups);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2615,7 +2617,7 @@ create_lockrows_plan(PlannerInfo *root, LockRowsPath *best_path,
 
 	plan = make_lockrows(subplan, best_path->rowMarks, best_path->epqParam);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2676,7 +2678,7 @@ create_modifytable_plan(PlannerInfo *root, ModifyTablePath *best_path)
 							best_path->onconflict,
 							best_path->epqParam);
 
-	copy_generic_path_info(&plan->plan, &best_path->path);
+	copy_generic_path_info(root, &plan->plan, &best_path->path);
 
 	return plan;
 }
@@ -2730,7 +2732,7 @@ create_limit_plan(PlannerInfo *root, LimitPath *best_path, int flags)
 					  best_path->limitOption,
 					  numUniqkeys, uniqColIdx, uniqOperators, uniqCollations);
 
-	copy_generic_path_info(&plan->plan, (Path *) best_path);
+	copy_generic_path_info(root, &plan->plan, (Path *) best_path);
 
 	return plan;
 }
@@ -2776,7 +2778,7 @@ create_seqscan_plan(PlannerInfo *root, Path *best_path,
 							 scan_clauses,
 							 scan_relid);
 
-	copy_generic_path_info(&scan_plan->plan, best_path);
+	copy_generic_path_info(root, &scan_plan->plan, best_path);
 
 	return scan_plan;
 }
@@ -2822,7 +2824,7 @@ create_samplescan_plan(PlannerInfo *root, Path *best_path,
 								scan_relid,
 								tsc);
 
-	copy_generic_path_info(&scan_plan->scan.plan, best_path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, best_path);
 
 	return scan_plan;
 }
@@ -3000,7 +3002,7 @@ create_indexscan_plan(PlannerInfo *root,
 											indexorderbyops,
 											best_path->indexscandir);
 
-	copy_generic_path_info(&scan_plan->plan, &best_path->path);
+	copy_generic_path_info(root, &scan_plan->plan, &best_path->path);
 
 	return scan_plan;
 }
@@ -3115,7 +3117,7 @@ create_bitmap_scan_plan(PlannerInfo *root,
 									 bitmapqualorig,
 									 baserelid);
 
-	copy_generic_path_info(&scan_plan->scan.plan, &best_path->path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, &best_path->path);
 
 	return scan_plan;
 }
@@ -3435,7 +3437,7 @@ create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
 							 scan_relid,
 							 tidquals);
 
-	copy_generic_path_info(&scan_plan->scan.plan, &best_path->path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, &best_path->path);
 
 	return scan_plan;
 }
@@ -3485,7 +3487,7 @@ create_subqueryscan_plan(PlannerInfo *root, SubqueryScanPath *best_path,
 								  scan_relid,
 								  subplan);
 
-	copy_generic_path_info(&scan_plan->scan.plan, &best_path->path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, &best_path->path);
 
 	return scan_plan;
 }
@@ -3528,7 +3530,7 @@ create_functionscan_plan(PlannerInfo *root, Path *best_path,
 	scan_plan = make_functionscan(tlist, scan_clauses, scan_relid,
 								  functions, rte->funcordinality);
 
-	copy_generic_path_info(&scan_plan->scan.plan, best_path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, best_path);
 
 	return scan_plan;
 }
@@ -3571,7 +3573,7 @@ create_tablefuncscan_plan(PlannerInfo *root, Path *best_path,
 	scan_plan = make_tablefuncscan(tlist, scan_clauses, scan_relid,
 								   tablefunc);
 
-	copy_generic_path_info(&scan_plan->scan.plan, best_path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, best_path);
 
 	return scan_plan;
 }
@@ -3615,7 +3617,7 @@ create_valuesscan_plan(PlannerInfo *root, Path *best_path,
 	scan_plan = make_valuesscan(tlist, scan_clauses, scan_relid,
 								values_lists);
 
-	copy_generic_path_info(&scan_plan->scan.plan, best_path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, best_path);
 
 	return scan_plan;
 }
@@ -3708,7 +3710,7 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
 	scan_plan = make_ctescan(tlist, scan_clauses, scan_relid,
 							 plan_id, cte_param_id);
 
-	copy_generic_path_info(&scan_plan->scan.plan, best_path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, best_path);
 
 	return scan_plan;
 }
@@ -3747,7 +3749,7 @@ create_namedtuplestorescan_plan(PlannerInfo *root, Path *best_path,
 	scan_plan = make_namedtuplestorescan(tlist, scan_clauses, scan_relid,
 										 rte->enrname);
 
-	copy_generic_path_info(&scan_plan->scan.plan, best_path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, best_path);
 
 	return scan_plan;
 }
@@ -3785,7 +3787,7 @@ create_resultscan_plan(PlannerInfo *root, Path *best_path,
 
 	scan_plan = make_result(tlist, (Node *) scan_clauses, NULL);
 
-	copy_generic_path_info(&scan_plan->plan, best_path);
+	copy_generic_path_info(root, &scan_plan->plan, best_path);
 
 	return scan_plan;
 }
@@ -3845,7 +3847,7 @@ create_worktablescan_plan(PlannerInfo *root, Path *best_path,
 	scan_plan = make_worktablescan(tlist, scan_clauses, scan_relid,
 								   cteroot->wt_param_id);
 
-	copy_generic_path_info(&scan_plan->scan.plan, best_path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, best_path);
 
 	return scan_plan;
 }
@@ -3905,7 +3907,7 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 												outer_plan);
 
 	/* Copy cost data from Path to Plan; no need to make FDW do this */
-	copy_generic_path_info(&scan_plan->scan.plan, &best_path->path);
+	copy_generic_path_info(root, &scan_plan->scan.plan, &best_path->path);
 
 	/* Copy foreign server OID; likewise, no need to make FDW do this */
 	scan_plan->fs_server = rel->serverid;
@@ -4039,7 +4041,7 @@ create_customscan_plan(PlannerInfo *root, CustomPath *best_path,
 	 * Copy cost data from Path to Plan; no need to make custom-plan providers
 	 * do this
 	 */
-	copy_generic_path_info(&cplan->scan.plan, &best_path->path);
+	copy_generic_path_info(root, &cplan->scan.plan, &best_path->path);
 
 	/* Likewise, copy the relids that are represented by this custom scan */
 	cplan->custom_relids = best_path->path.parent->relids;
@@ -4141,7 +4143,7 @@ create_nestloop_plan(PlannerInfo *root,
 							  best_path->jointype,
 							  best_path->inner_unique);
 
-	copy_generic_path_info(&join_plan->join.plan, &best_path->path);
+	copy_generic_path_info(root, &join_plan->join.plan, &best_path->path);
 
 	return join_plan;
 }
@@ -4448,7 +4450,7 @@ create_mergejoin_plan(PlannerInfo *root,
 							   best_path->skip_mark_restore);
 
 	/* Costs of sort and material steps are included in path cost already */
-	copy_generic_path_info(&join_plan->join.plan, &best_path->jpath.path);
+	copy_generic_path_info(root, &join_plan->join.plan, &best_path->jpath.path);
 
 	return join_plan;
 }
@@ -4621,7 +4623,7 @@ create_hashjoin_plan(PlannerInfo *root,
 							  best_path->jpath.jointype,
 							  best_path->jpath.inner_unique);
 
-	copy_generic_path_info(&join_plan->join.plan, &best_path->jpath.path);
+	copy_generic_path_info(root, &join_plan->join.plan, &best_path->jpath.path);
 
 	return join_plan;
 }
@@ -5121,7 +5123,7 @@ order_qual_clauses(PlannerInfo *root, List *clauses)
  * Also copy the parallel-related flags, which the executor *will* use.
  */
 static void
-copy_generic_path_info(Plan *dest, Path *src)
+copy_generic_path_info(PlannerInfo *root, Plan *dest, Path *src)
 {
 	dest->startup_cost = src->startup_cost;
 	dest->total_cost = src->total_cost;
@@ -5129,6 +5131,9 @@ copy_generic_path_info(Plan *dest, Path *src)
 	dest->plan_width = src->pathtarget->width;
 	dest->parallel_aware = src->parallel_aware;
 	dest->parallel_safe = src->parallel_safe;
+
+	if (copy_generic_path_info_hook)
+		(*copy_generic_path_info_hook) (root, dest, src);
 }
 
 /*
diff --git a/src/backend/optimizer/util/relnode.c b/src/backend/optimizer/util/relnode.c
index 731ff708b9..e862e2a974 100644
--- a/src/backend/optimizer/util/relnode.c
+++ b/src/backend/optimizer/util/relnode.c
@@ -1260,6 +1260,7 @@ find_childrel_parents(PlannerInfo *root, RelOptInfo *rel)
 }
 
 
+set_parampathinfo_postinit_hook_type parampathinfo_postinit_hook = NULL;
 /*
  * get_baserel_parampathinfo
  *		Get the ParamPathInfo for a parameterized path for a base relation,
@@ -1328,6 +1329,10 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 	ppi->ppi_req_outer = required_outer;
 	ppi->ppi_rows = rows;
 	ppi->ppi_clauses = pclauses;
+
+	if (parampathinfo_postinit_hook)
+		(*parampathinfo_postinit_hook)(ppi);
+
 	baserel->ppilist = lappend(baserel->ppilist, ppi);
 
 	return ppi;
@@ -1553,6 +1558,10 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 	ppi->ppi_req_outer = required_outer;
 	ppi->ppi_rows = rows;
 	ppi->ppi_clauses = NIL;
+
+	if (parampathinfo_postinit_hook)
+			(*parampathinfo_postinit_hook)(ppi);
+
 	joinrel->ppilist = lappend(joinrel->ppilist, ppi);
 
 	return ppi;
diff --git a/src/include/commands/explain.h b/src/include/commands/explain.h
index e94d9e49cf..4404155fbd 100644
--- a/src/include/commands/explain.h
+++ b/src/include/commands/explain.h
@@ -75,6 +75,12 @@ extern PGDLLIMPORT ExplainOneQuery_hook_type ExplainOneQuery_hook;
 typedef const char *(*explain_get_index_name_hook_type) (Oid indexId);
 extern PGDLLIMPORT explain_get_index_name_hook_type explain_get_index_name_hook;
 
+/* Hook for plugins to get control in ExplainOnePlan() */
+typedef void (*ExplainOnePlan_hook_type) (PlannedStmt *plannedstmt, IntoClause *into,
+			   ExplainState *es, const char *queryString,
+			   ParamListInfo params, const instr_time *planduration,
+			   QueryEnvironment *queryEnv);
+extern PGDLLIMPORT ExplainOnePlan_hook_type ExplainOnePlan_hook;
 
 extern void ExplainQuery(ParseState *pstate, ExplainStmt *stmt,
 						 ParamListInfo params, DestReceiver *dest);
diff --git a/src/include/nodes/pathnodes.h b/src/include/nodes/pathnodes.h
index cde2637798..74ffaa9c8a 100644
--- a/src/include/nodes/pathnodes.h
+++ b/src/include/nodes/pathnodes.h
@@ -739,6 +739,10 @@ typedef struct RelOptInfo
 	Relids		top_parent_relids;	/* Relids of topmost parents (if "other"
 									 * rel) */
 
+	/* For Adaptive optimization DEBUG purposes */
+	double		predicted_cardinality;
+	int			fss_hash;
+
 	/* used for partitioned relations: */
 	PartitionScheme part_scheme;	/* Partitioning scheme */
 	int			nparts;			/* Number of partitions; -1 if not yet set; in
@@ -1107,6 +1111,10 @@ typedef struct ParamPathInfo
 	Relids		ppi_req_outer;	/* rels supplying parameters used by path */
 	double		ppi_rows;		/* estimated number of result tuples */
 	List	   *ppi_clauses;	/* join clauses available from outer rels */
+
+	/* AQO DEBUG purposes */
+	double predicted_ppi_rows;
+	double fss_ppi_hash;
 } ParamPathInfo;
 
 
diff --git a/src/include/nodes/plannodes.h b/src/include/nodes/plannodes.h
index 43160439f0..86988ca32d 100644
--- a/src/include/nodes/plannodes.h
+++ b/src/include/nodes/plannodes.h
@@ -140,6 +140,19 @@ typedef struct Plan
 	List	   *initPlan;		/* Init Plan nodes (un-correlated expr
 								 * subselects) */
 
+	/*
+	 * information for adaptive query optimization
+	 */
+	bool		had_path;
+	List	   *path_clauses;
+	List	   *path_relids;
+	JoinType	path_jointype;
+	int			path_parallel_workers;
+	bool		was_parametrized;
+	/* For Adaptive optimization DEBUG purposes */
+	double		predicted_cardinality;
+	int			fss_hash;
+
 	/*
 	 * Information for management of parameter-change-driven rescanning
 	 *
diff --git a/src/include/optimizer/cost.h b/src/include/optimizer/cost.h
index ed2e4af4be..7e3cbcca14 100644
--- a/src/include/optimizer/cost.h
+++ b/src/include/optimizer/cost.h
@@ -39,6 +39,37 @@ typedef enum
 }			ConstraintExclusionType;
 
 
+/* Hook for plugins to get control of cardinality estimation */
+typedef void (*set_baserel_rows_estimate_hook_type) (PlannerInfo *root,
+															RelOptInfo *rel);
+typedef void (*set_foreign_rows_estimate_hook_type) (PlannerInfo *root,
+													RelOptInfo *rel);
+extern PGDLLIMPORT set_baserel_rows_estimate_hook_type
+			set_baserel_rows_estimate_hook;
+extern PGDLLIMPORT set_foreign_rows_estimate_hook_type
+												set_foreign_rows_estimate_hook;
+typedef double (*get_parameterized_baserel_size_hook_type) (PlannerInfo *root,
+															 RelOptInfo *rel,
+														List *param_clauses);
+extern PGDLLIMPORT get_parameterized_baserel_size_hook_type
+			get_parameterized_baserel_size_hook;
+typedef double (*get_parameterized_joinrel_size_hook_type) (PlannerInfo *root,
+															 RelOptInfo *rel,
+															Path *outer_path,
+															Path *inner_path,
+													 SpecialJoinInfo *sjinfo,
+													 List *restrict_clauses);
+extern PGDLLIMPORT get_parameterized_joinrel_size_hook_type
+			get_parameterized_joinrel_size_hook;
+typedef void (*set_joinrel_size_estimates_hook_type) (PlannerInfo *root,
+															 RelOptInfo *rel,
+													   RelOptInfo *outer_rel,
+													   RelOptInfo *inner_rel,
+													 SpecialJoinInfo *sjinfo,
+														 List *restrictlist);
+extern PGDLLIMPORT set_joinrel_size_estimates_hook_type
+			set_joinrel_size_estimates_hook;
+
 /*
  * prototypes for costsize.c
  *	  routines to compute costs and sizes
@@ -175,10 +206,22 @@ extern void compute_semi_anti_join_factors(PlannerInfo *root,
 										   SpecialJoinInfo *sjinfo,
 										   List *restrictlist,
 										   SemiAntiJoinFactors *semifactors);
+extern void set_foreign_rows_estimate(PlannerInfo *root, RelOptInfo *rel);
+extern void set_baserel_rows_estimate(PlannerInfo *root, RelOptInfo *rel);
+extern void set_baserel_rows_estimate_standard(PlannerInfo *root, RelOptInfo *rel);
 extern void set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel);
 extern double get_parameterized_baserel_size(PlannerInfo *root,
 											 RelOptInfo *rel,
 											 List *param_clauses);
+extern double get_parameterized_baserel_size_standard(PlannerInfo *root,
+										RelOptInfo *rel,
+										List *param_clauses);
+extern double get_parameterized_joinrel_size_standard(PlannerInfo *root,
+										RelOptInfo *rel,
+										Path *outer_path,
+										Path *inner_path,
+										SpecialJoinInfo *sjinfo,
+										List *restrict_clauses);
 extern double get_parameterized_joinrel_size(PlannerInfo *root,
 											 RelOptInfo *rel,
 											 Path *outer_path,
@@ -190,6 +233,11 @@ extern void set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
 									   RelOptInfo *inner_rel,
 									   SpecialJoinInfo *sjinfo,
 									   List *restrictlist);
+extern void set_joinrel_size_estimates_standard(PlannerInfo *root, RelOptInfo *rel,
+									RelOptInfo *outer_rel,
+									RelOptInfo *inner_rel,
+									SpecialJoinInfo *sjinfo,
+									List *restrictlist);
 extern void set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel);
 extern void set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel);
 extern void set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel);
@@ -202,5 +250,7 @@ extern void set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel);
 extern PathTarget *set_pathtarget_cost_width(PlannerInfo *root, PathTarget *target);
 extern double compute_bitmap_pages(PlannerInfo *root, RelOptInfo *baserel,
 								   Path *bitmapqual, int loop_count, Cost *cost, double *tuple);
+extern bool IsParallelTuplesProcessing(const Plan *plan);
+extern double get_parallel_divisor(int parallel_workers);
 
 #endif							/* COST_H */
diff --git a/src/include/optimizer/pathnode.h b/src/include/optimizer/pathnode.h
index 23dec14cbd..58489cb620 100644
--- a/src/include/optimizer/pathnode.h
+++ b/src/include/optimizer/pathnode.h
@@ -18,6 +18,10 @@
 #include "nodes/pathnodes.h"
 
 
+typedef void (*set_parampathinfo_postinit_hook_type) (ParamPathInfo *ppi);
+
+extern PGDLLIMPORT set_parampathinfo_postinit_hook_type parampathinfo_postinit_hook;
+
 /*
  * prototypes for pathnode.c
  */
diff --git a/src/include/optimizer/planmain.h b/src/include/optimizer/planmain.h
index 777655210b..dac8231291 100644
--- a/src/include/optimizer/planmain.h
+++ b/src/include/optimizer/planmain.h
@@ -24,6 +24,12 @@ extern double cursor_tuple_fraction;
 /* query_planner callback to compute query_pathkeys */
 typedef void (*query_pathkeys_callback) (PlannerInfo *root, void *extra);
 
+/* hook for plugins to get control in creating plan from path */
+typedef void (*copy_generic_path_info_hook_type) (PlannerInfo *root,
+													  Plan *dest, Path *src);
+
+extern PGDLLIMPORT copy_generic_path_info_hook_type copy_generic_path_info_hook;
+
 /*
  * prototypes for plan/planmain.c
  */
